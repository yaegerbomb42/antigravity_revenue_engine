// ============================================================================
// YouTube Transcript Extraction Engine
// ============================================================================

import { VideoMetadata, TranscriptSegment, VideoChapter, ThumbnailInfo } from '@/types';

// ----------------------------------------------------------------------------
// Configuration
// ----------------------------------------------------------------------------

interface TranscriptConfig {
  preferredLanguages: string[];
  includeAutoGenerated: boolean;
  mergeSegments: boolean;
  segmentMergeThreshold: number; // seconds
  cleanupText: boolean;
  retryAttempts: number;
  timeout: number;
}

const DEFAULT_CONFIG: TranscriptConfig = {
  preferredLanguages: ['en', 'en-US', 'en-GB'],
  includeAutoGenerated: true,
  mergeSegments: true,
  segmentMergeThreshold: 2.0,
  cleanupText: true,
  retryAttempts: 3,
  timeout: 30000,
};

// ----------------------------------------------------------------------------
// YouTube URL Parsing
// ----------------------------------------------------------------------------

interface ParsedYouTubeURL {
  videoId: string;
  playlistId?: string;
  timestamp?: number;
  isShort: boolean;
  isEmbed: boolean;
  isValid: boolean;
}

const YOUTUBE_URL_PATTERNS = [
  // Standard watch URL
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
  // Short URL
  /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})/,
  // Embed URL
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/,
  // Shorts URL
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
  // Live URL
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/live\/([a-zA-Z0-9_-]{11})/,
  // Attribution URL
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/attribution_link\?.*v=([a-zA-Z0-9_-]{11})/,
  // Mobile URL
  /(?:https?:\/\/)?m\.youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
];

export function parseYouTubeURL(url: string): ParsedYouTubeURL {
  const result: ParsedYouTubeURL = {
    videoId: '',
    isShort: false,
    isEmbed: false,
    isValid: false,
  };

  if (!url) return result;

  // Clean URL
  const cleanUrl = url.trim();

  // Try each pattern
  for (const pattern of YOUTUBE_URL_PATTERNS) {
    const match = cleanUrl.match(pattern);
    if (match && match[1]) {
      result.videoId = match[1];
      result.isValid = true;

      // Check for shorts
      if (cleanUrl.includes('/shorts/')) {
        result.isShort = true;
      }

      // Check for embed
      if (cleanUrl.includes('/embed/')) {
        result.isEmbed = true;
      }

      break;
    }
  }

  // Extract playlist ID if present
  const playlistMatch = cleanUrl.match(/[?&]list=([a-zA-Z0-9_-]+)/);
  if (playlistMatch) {
    result.playlistId = playlistMatch[1];
  }

  // Extract timestamp if present
  const timeMatch = cleanUrl.match(/[?&]t=(\d+)s?/);
  if (timeMatch) {
    result.timestamp = parseInt(timeMatch[1], 10);
  }

  // Also check for different time format (e.g., t=1m30s)
  const timeMatch2 = cleanUrl.match(/[?&]t=(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s?)?/);
  if (timeMatch2) {
    const hours = parseInt(timeMatch2[1] || '0', 10);
    const minutes = parseInt(timeMatch2[2] || '0', 10);
    const seconds = parseInt(timeMatch2[3] || '0', 10);
    result.timestamp = hours * 3600 + minutes * 60 + seconds;
  }

  return result;
}

export function isValidYouTubeURL(url: string): boolean {
  return parseYouTubeURL(url).isValid;
}

export function extractVideoId(url: string): string | null {
  const parsed = parseYouTubeURL(url);
  return parsed.isValid ? parsed.videoId : null;
}

// ----------------------------------------------------------------------------
// Text Cleanup Utilities
// ----------------------------------------------------------------------------

interface CleanupOptions {
  removeTimestamps: boolean;
  removeSpeakerLabels: boolean;
  removeFillerWords: boolean;
  normalizeWhitespace: boolean;
  fixPunctuation: boolean;
  removeMusic: boolean;
  removeApplause: boolean;
}

const DEFAULT_CLEANUP_OPTIONS: CleanupOptions = {
  removeTimestamps: true,
  removeSpeakerLabels: false,
  removeFillerWords: false,
  normalizeWhitespace: true,
  fixPunctuation: true,
  removeMusic: true,
  removeApplause: true,
};

const FILLER_WORDS = new Set([
  'um', 'uh', 'er', 'ah', 'like', 'you know', 'i mean', 'sort of',
  'kind of', 'basically', 'actually', 'literally', 'honestly',
]);

const NON_SPEECH_PATTERNS = [
  /\[music\]/gi,
  /\[applause\]/gi,
  /\[laughter\]/gi,
  /\[cheering\]/gi,
  /\[silence\]/gi,
  /\[inaudible\]/gi,
  /\[crosstalk\]/gi,
  /‚ô™.*?‚ô™/g,
  /üéµ.*?üéµ/g,
  /\(.*?music.*?\)/gi,
  /\(.*?applause.*?\)/gi,
];

const SPEAKER_LABEL_PATTERNS = [
  /^[A-Z][A-Za-z\s]+:/,
  /^\[[A-Z][A-Za-z\s]+\]/,
  /^Speaker \d+:/i,
  /^Person \d+:/i,
];

export function cleanTranscriptText(
  text: string,
  options: Partial<CleanupOptions> = {}
): string {
  const opts = { ...DEFAULT_CLEANUP_OPTIONS, ...options };
  let result = text;

  // Remove non-speech elements
  if (opts.removeMusic || opts.removeApplause) {
    for (const pattern of NON_SPEECH_PATTERNS) {
      result = result.replace(pattern, '');
    }
  }

  // Remove speaker labels
  if (opts.removeSpeakerLabels) {
    for (const pattern of SPEAKER_LABEL_PATTERNS) {
      result = result.replace(pattern, '');
    }
  }

  // Remove filler words
  if (opts.removeFillerWords) {
    for (const filler of FILLER_WORDS) {
      const pattern = new RegExp(`\\b${filler}\\b`, 'gi');
      result = result.replace(pattern, '');
    }
  }

  // Normalize whitespace
  if (opts.normalizeWhitespace) {
    result = result
      .replace(/\s+/g, ' ')
      .replace(/\n\s*\n/g, '\n')
      .trim();
  }

  // Fix punctuation
  if (opts.fixPunctuation) {
    result = result
      .replace(/\s+([.,!?;:])/g, '$1')
      .replace(/([.,!?;:])\s*([A-Z])/g, '$1 $2')
      .replace(/\s{2,}/g, ' ');
  }

  return result;
}

// ----------------------------------------------------------------------------
// Transcript Segment Processing
// ----------------------------------------------------------------------------

interface RawTranscriptSegment {
  text: string;
  start: number;
  duration: number;
}

export function processTranscriptSegments(
  rawSegments: RawTranscriptSegment[],
  config: Partial<TranscriptConfig> = {}
): TranscriptSegment[] {
  const opts = { ...DEFAULT_CONFIG, ...config };

  // Clean and process each segment
  let segments: TranscriptSegment[] = rawSegments.map((seg, index) => ({
    id: `segment_${index}`,
    text: opts.cleanupText ? cleanTranscriptText(seg.text) : seg.text,
    startTime: seg.start,
    endTime: seg.start + seg.duration,
    duration: seg.duration,
    confidence: 1.0, // Default confidence
    speaker: undefined,
  }));

  // Filter empty segments
  segments = segments.filter(seg => seg.text.trim().length > 0);

  // Merge close segments if enabled
  if (opts.mergeSegments) {
    segments = mergeCloseSegments(segments, opts.segmentMergeThreshold);
  }

  // Recalculate IDs
  segments = segments.map((seg, index) => ({
    ...seg,
    id: `segment_${index}`,
  }));

  return segments;
}

function mergeCloseSegments(
  segments: TranscriptSegment[],
  threshold: number
): TranscriptSegment[] {
  if (segments.length === 0) return [];

  const merged: TranscriptSegment[] = [];
  let current = { ...segments[0] };

  for (let i = 1; i < segments.length; i++) {
    const next = segments[i];
    const gap = next.startTime - current.endTime;

    if (gap <= threshold && current.text.length + next.text.length < 500) {
      // Merge segments
      current = {
        ...current,
        text: current.text + ' ' + next.text,
        endTime: next.endTime,
        duration: next.endTime - current.startTime,
        confidence: Math.min(current.confidence, next.confidence),
      };
    } else {
      merged.push(current);
      current = { ...next };
    }
  }

  merged.push(current);
  return merged;
}

// ----------------------------------------------------------------------------
// Chapter Detection
// ----------------------------------------------------------------------------

interface ChapterMarker {
  time: number;
  title: string;
}

const CHAPTER_TIMESTAMP_PATTERN = /(?:^|\n)(\d{1,2}:)?(\d{1,2}):(\d{2})\s*[-‚Äì‚Äî]?\s*(.+?)(?:\n|$)/g;

export function detectChaptersFromDescription(description: string): VideoChapter[] {
  const chapters: VideoChapter[] = [];
  const markers: ChapterMarker[] = [];

  // Extract timestamp markers
  let match;
  while ((match = CHAPTER_TIMESTAMP_PATTERN.exec(description)) !== null) {
    const hours = match[1] ? parseInt(match[1].replace(':', ''), 10) : 0;
    const minutes = parseInt(match[2], 10);
    const seconds = parseInt(match[3], 10);
    const title = match[4].trim();

    markers.push({
      time: hours * 3600 + minutes * 60 + seconds,
      title,
    });
  }

  // Sort by time
  markers.sort((a, b) => a.time - b.time);

  // Convert to chapters
  for (let i = 0; i < markers.length; i++) {
    const endTime = i < markers.length - 1 ? markers[i + 1].time : undefined;

    chapters.push({
      id: `chapter_${i}`,
      title: markers[i].title,
      startTime: markers[i].time,
      endTime,
      thumbnailUrl: undefined,
    });
  }

  return chapters;
}

export function assignChaptersToSegments(
  segments: TranscriptSegment[],
  chapters: VideoChapter[]
): Map<string, string> {
  const segmentChapterMap = new Map<string, string>();

  for (const segment of segments) {
    const chapter = chapters.find(ch =>
      segment.startTime >= ch.startTime &&
      (!ch.endTime || segment.startTime < ch.endTime)
    );

    if (chapter) {
      segmentChapterMap.set(segment.id, chapter.id);
    }
  }

  return segmentChapterMap;
}

// ----------------------------------------------------------------------------
// Speaker Detection (Basic Heuristics)
// ----------------------------------------------------------------------------

interface SpeakerSegment {
  speaker: string;
  segments: string[];
}

export function detectSpeakers(segments: TranscriptSegment[]): SpeakerSegment[] {
  const speakerSegments: SpeakerSegment[] = [];
  let currentSpeaker = 'Speaker 1';
  let speakerCount = 1;

  const speakerIndicators = {
    question: ['?', 'what', 'how', 'why', 'when', 'where', 'who', 'which'],
    longPause: 2.0, // seconds
    sentimentShift: 0.5,
  };

  let currentSegments: string[] = [];

  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const prevSegment = i > 0 ? segments[i - 1] : null;

    // Check for speaker change indicators
    let speakerChange = false;

    // Long pause between segments
    if (prevSegment && (segment.startTime - prevSegment.endTime) > speakerIndicators.longPause) {
      speakerChange = true;
    }

    // Explicit speaker label in text
    const speakerMatch = segment.text.match(/^([A-Z][a-z]+):\s/);
    if (speakerMatch) {
      const newSpeaker = speakerMatch[1];
      if (newSpeaker !== currentSpeaker) {
        speakerChange = true;
        currentSpeaker = newSpeaker;
      }
    }

    // Q&A pattern detection
    if (prevSegment) {
      const prevEndsWithQuestion = prevSegment.text.trim().endsWith('?');
      const currentStartsWithAnswer = !segment.text.trim().startsWith('?');
      if (prevEndsWithQuestion && currentStartsWithAnswer) {
        speakerChange = true;
      }
    }

    if (speakerChange && currentSegments.length > 0) {
      speakerSegments.push({
        speaker: currentSpeaker,
        segments: [...currentSegments],
      });
      currentSegments = [];
      speakerCount++;
      if (!speakerMatch) {
        currentSpeaker = `Speaker ${speakerCount}`;
      }
    }

    currentSegments.push(segment.id);
  }

  // Add remaining segments
  if (currentSegments.length > 0) {
    speakerSegments.push({
      speaker: currentSpeaker,
      segments: currentSegments,
    });
  }

  return speakerSegments;
}

// ----------------------------------------------------------------------------
// Thumbnail Utilities
// ----------------------------------------------------------------------------

export function generateThumbnailURLs(videoId: string): ThumbnailInfo[] {
  const qualities = [
    { quality: 'maxres', width: 1280, height: 720, suffix: 'maxresdefault' },
    { quality: 'sd', width: 640, height: 480, suffix: 'sddefault' },
    { quality: 'hq', width: 480, height: 360, suffix: 'hqdefault' },
    { quality: 'mq', width: 320, height: 180, suffix: 'mqdefault' },
    { quality: 'default', width: 120, height: 90, suffix: 'default' },
  ];

  return qualities.map(q => ({
    url: `https://img.youtube.com/vi/${videoId}/${q.suffix}.jpg`,
    width: q.width,
    height: q.height,
    quality: q.quality as ThumbnailInfo['quality'],
  }));
}

export function getBestThumbnail(thumbnails: ThumbnailInfo[]): ThumbnailInfo | null {
  if (thumbnails.length === 0) return null;

  // Sort by quality (maxres first)
  const qualityOrder = ['maxres', 'sd', 'hq', 'mq', 'default'];

  return [...thumbnails].sort((a, b) => {
    const aIndex = qualityOrder.indexOf(a.quality);
    const bIndex = qualityOrder.indexOf(b.quality);
    return aIndex - bIndex;
  })[0];
}

// ----------------------------------------------------------------------------
// Duration Parsing
// ----------------------------------------------------------------------------

export function parseDuration(durationStr: string): number {
  // Parse ISO 8601 duration format (PT1H2M3S)
  const isoMatch = durationStr.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
  if (isoMatch) {
    const hours = parseInt(isoMatch[1] || '0', 10);
    const minutes = parseInt(isoMatch[2] || '0', 10);
    const seconds = parseInt(isoMatch[3] || '0', 10);
    return hours * 3600 + minutes * 60 + seconds;
  }

  // Parse HH:MM:SS or MM:SS format
  const timeMatch = durationStr.match(/(?:(\d+):)?(\d+):(\d+)/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1] || '0', 10);
    const minutes = parseInt(timeMatch[2], 10);
    const seconds = parseInt(timeMatch[3], 10);
    return hours * 3600 + minutes * 60 + seconds;
  }

  // Parse plain seconds
  const secondsMatch = durationStr.match(/^(\d+)$/);
  if (secondsMatch) {
    return parseInt(secondsMatch[1], 10);
  }

  return 0;
}

export function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// ----------------------------------------------------------------------------
// View Count Parsing
// ----------------------------------------------------------------------------

export function parseViewCount(viewStr: string): number {
  // Remove non-numeric characters except for K, M, B
  const cleaned = viewStr.toUpperCase().replace(/[^0-9.KMB]/g, '');

  const multipliers: Record<string, number> = {
    'K': 1000,
    'M': 1000000,
    'B': 1000000000,
  };

  for (const [suffix, multiplier] of Object.entries(multipliers)) {
    if (cleaned.endsWith(suffix)) {
      const num = parseFloat(cleaned.replace(suffix, ''));
      return Math.round(num * multiplier);
    }
  }

  return parseInt(cleaned, 10) || 0;
}

export function formatViewCount(count: number): string {
  if (count >= 1000000000) {
    return `${(count / 1000000000).toFixed(1)}B`;
  }
  if (count >= 1000000) {
    return `${(count / 1000000).toFixed(1)}M`;
  }
  if (count >= 1000) {
    return `${(count / 1000).toFixed(1)}K`;
  }
  return count.toString();
}

// ----------------------------------------------------------------------------
// Main Transcript Extractor Class
// ----------------------------------------------------------------------------

export class TranscriptExtractor {
  private config: TranscriptConfig;
  private cache: Map<string, ExtractedTranscript> = new Map();
  private maxCacheSize = 50;

  constructor(config: Partial<TranscriptConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Extract transcript from YouTube video
   */
  async extract(url: string): Promise<ExtractedTranscript> {
    const parsed = parseYouTubeURL(url);

    if (!parsed.isValid) {
      throw new TranscriptError('INVALID_URL', 'Invalid YouTube URL provided');
    }

    // Check cache
    if (this.cache.has(parsed.videoId)) {
      return this.cache.get(parsed.videoId)!;
    }

    try {
      // In a real implementation, this would call YouTube API or scrape
      // For now, we'll simulate the extraction process
      const result = await this.extractFromVideoId(parsed.videoId);

      // Cache result
      if (this.cache.size >= this.maxCacheSize) {
        const firstKey = this.cache.keys().next().value;
        if (firstKey) this.cache.delete(firstKey);
      }
      this.cache.set(parsed.videoId, result);

      return result;
    } catch (error) {
      if (error instanceof TranscriptError) {
        throw error;
      }
      throw new TranscriptError('EXTRACTION_FAILED', `Failed to extract transcript: ${error}`);
    }
  }

  /**
   * Extract transcript from video ID
   */
  private async extractFromVideoId(videoId: string): Promise<ExtractedTranscript> {
    // Simulate API call delay
    await this.delay(100);

    // Get video metadata
    const metadata = await this.fetchVideoMetadata(videoId);

    // Get transcript segments
    const segments = await this.fetchTranscriptSegments(videoId);

    // Detect chapters from description
    const chapters = detectChaptersFromDescription(metadata.description);

    // Detect speakers
    const speakerSegments = detectSpeakers(segments);

    // Generate full transcript text
    const fullText = segments.map(s => s.text).join(' ');

    // Calculate transcript statistics
    const statistics = this.calculateStatistics(segments, fullText);

    return {
      videoId,
      metadata,
      segments,
      chapters,
      speakers: speakerSegments,
      fullText,
      statistics,
      language: this.detectLanguage(fullText),
      isAutoGenerated: true, // Would be determined from API
      extractedAt: new Date().toISOString(),
    };
  }

  /**
   * Fetch video metadata (simulated)
   */
  private async fetchVideoMetadata(videoId: string): Promise<VideoMetadata> {
    // In production, this would call YouTube Data API
    // For now, return placeholder that demonstrates the structure

    const thumbnails = generateThumbnailURLs(videoId);

    return {
      id: videoId,
      title: 'Video Title',
      description: 'Video description with potential chapter timestamps:\n0:00 - Introduction\n1:30 - Main Content\n5:00 - Conclusion',
      channelId: 'channel_id',
      channelTitle: 'Channel Name',
      publishedAt: new Date().toISOString(),
      duration: 300,
      viewCount: 0,
      likeCount: 0,
      commentCount: 0,
      thumbnails,
      tags: [],
      categoryId: '22', // People & Blogs
      defaultLanguage: 'en',
      liveBroadcastContent: 'none',
    };
  }

  /**
   * Fetch transcript segments (simulated)
   */
  private async fetchTranscriptSegments(videoId: string): Promise<TranscriptSegment[]> {
    // In production, this would fetch from YouTube's caption tracks
    // For demonstration, return empty array - real data comes from API integration

    // The actual implementation would:
    // 1. Fetch the video page HTML
    // 2. Extract the caption track URLs from the player response
    // 3. Fetch the appropriate caption track (preferring manual over auto-generated)
    // 4. Parse the caption data (XML, JSON3, or SRV format)
    // 5. Process and return the segments

    return [];
  }

  /**
   * Calculate transcript statistics
   */
  private calculateStatistics(
    segments: TranscriptSegment[],
    fullText: string
  ): TranscriptStatistics {
    const words = fullText.split(/\s+/).filter(w => w.length > 0);
    const sentences = fullText.split(/[.!?]+/).filter(s => s.trim().length > 0);

    const totalDuration = segments.length > 0
      ? segments[segments.length - 1].endTime - segments[0].startTime
      : 0;

    return {
      wordCount: words.length,
      sentenceCount: sentences.length,
      segmentCount: segments.length,
      totalDuration,
      wordsPerMinute: totalDuration > 0 ? (words.length / totalDuration) * 60 : 0,
      avgSegmentDuration: segments.length > 0 ? totalDuration / segments.length : 0,
      avgWordsPerSegment: segments.length > 0 ? words.length / segments.length : 0,
    };
  }

  /**
   * Simple language detection
   */
  private detectLanguage(text: string): string {
    // Simple heuristic-based language detection
    const sample = text.substring(0, 1000).toLowerCase();

    const languageIndicators: Record<string, string[]> = {
      'en': ['the', 'and', 'is', 'to', 'of', 'a', 'in', 'that', 'it', 'was'],
      'es': ['el', 'la', 'de', 'que', 'y', 'en', 'un', 'es', 'se', 'no'],
      'fr': ['le', 'la', 'de', 'et', 'est', 'en', 'que', 'une', 'il', 'ne'],
      'de': ['der', 'die', 'und', 'in', 'den', 'von', 'zu', 'das', 'mit', 'sich'],
      'pt': ['de', 'que', 'e', 'o', 'da', 'em', 'um', 'para', 'com', 'n√£o'],
      'it': ['di', 'che', '√®', 'la', 'il', 'un', 'per', 'sono', 'non', 'della'],
      'ja': ['„ÅÆ', '„ÅØ', '„Å´', '„Çí', '„Åü', '„Åå', '„Åß', '„Å¶', '„Å®', '„Åó'],
      'ko': ['Ïù¥', 'Îäî', 'Í∞Ä', 'ÏùÑ', 'Ïùò', 'Ïóê', 'Î•º', 'Î°ú', 'Ìïò', 'Îã§'],
      'zh': ['ÁöÑ', 'ÊòØ', 'Âú®', '‰∫Ü', '‰∏ç', 'Âíå', 'Êúâ', 'Ëøô', '‰∏∫', 'Êàë'],
    };

    const scores: Record<string, number> = {};

    for (const [lang, indicators] of Object.entries(languageIndicators)) {
      let score = 0;
      for (const word of indicators) {
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = sample.match(regex);
        if (matches) {
          score += matches.length;
        }
      }
      scores[lang] = score;
    }

    // Return language with highest score
    let maxLang = 'en';
    let maxScore = 0;

    for (const [lang, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        maxLang = lang;
      }
    }

    return maxLang;
  }

  /**
   * Utility delay function
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Clear cache
   */
  clearCache(): void {
    this.cache.clear();
  }
}

// ----------------------------------------------------------------------------
// Types
// ----------------------------------------------------------------------------

export interface ExtractedTranscript {
  videoId: string;
  metadata: VideoMetadata;
  segments: TranscriptSegment[];
  chapters: VideoChapter[];
  speakers: SpeakerSegment[];
  fullText: string;
  statistics: TranscriptStatistics;
  language: string;
  isAutoGenerated: boolean;
  extractedAt: string;
}

export interface TranscriptStatistics {
  wordCount: number;
  sentenceCount: number;
  segmentCount: number;
  totalDuration: number;
  wordsPerMinute: number;
  avgSegmentDuration: number;
  avgWordsPerSegment: number;
}

export class TranscriptError extends Error {
  code: string;

  constructor(code: string, message: string) {
    super(message);
    this.code = code;
    this.name = 'TranscriptError';
  }
}

// ----------------------------------------------------------------------------
// Export
// ----------------------------------------------------------------------------

export const transcriptExtractor = new TranscriptExtractor();

export async function extractTranscript(url: string): Promise<ExtractedTranscript> {
  return transcriptExtractor.extract(url);
}

export {
  parseYouTubeURL,
  isValidYouTubeURL,
  extractVideoId,
  cleanTranscriptText,
  processTranscriptSegments,
  detectChaptersFromDescription,
  assignChaptersToSegments,
  detectSpeakers,
  generateThumbnailURLs,
  getBestThumbnail,
  parseDuration,
  formatDuration,
  parseViewCount,
  formatViewCount,
};
